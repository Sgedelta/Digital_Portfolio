/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./client/js/Herder/classes.js":
/*!*************************************!*\
  !*** ./client/js/Herder/classes.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const utils = __webpack_require__(/*! ./utilities.js */ \"./client/js/Herder/utilities.js\");\nclass agent extends PIXI.Sprite {\n  constructor(load, x, y, scale, speed) {\n    super(load);\n    this.anchor.set(.5, .5);\n    this.scale.set(scale);\n    this.x = x;\n    this.y = y;\n    this.fwd = utils.getRandomUnitVector();\n    this.desiredDirection = this.fwd;\n    this.speed = speed;\n    this.size = 10;\n    this.borderSize = 30;\n    this.isAlive = true;\n    this.eventMode = 'dynamic';\n  }\n  move(dt = 1 / 60) {\n    this.x += this.fwd.x * this.speed * dt;\n    this.y += this.fwd.y * this.speed * dt;\n  }\n  rotateToFwd() {\n    this.rotation = Math.PI / 2 + Math.atan2(this.fwd.y, this.fwd.x);\n  }\n  seek(targetX = 0, targetY = 0, str = 1) {\n    this.desiredDirection = {\n      x: this.desiredDirection.x + (targetX - this.x) * str,\n      y: this.desiredDirection.y + (targetY - this.y) * str\n    };\n  }\n  flee(targetX = 0, targetY = 0, str = 1) {\n    this.desiredDirection = {\n      x: this.desiredDirection.x - (targetX - this.x) * str,\n      y: this.desiredDirection.y - (targetY - this.y) * str\n    };\n  }\n  normalizeDesiredDir() {\n    let x = this.desiredDirection.x;\n    let y = this.desiredDirection.y;\n    let length = Math.sqrt(x * x + y * y);\n    if (length == 0) {\n      // very unlikely\n      x = 1; // point right\n      y = 0;\n      length = 1;\n    } else {\n      x /= length;\n      y /= length;\n    }\n    this.desiredDirection = {\n      x: x,\n      y: y\n    };\n  }\n  steer(steerStr) {\n    this.fwd = {\n      x: utils.lerp(this.fwd.x, this.desiredDirection.x, steerStr),\n      y: utils.lerp(this.fwd.y, this.desiredDirection.y, steerStr)\n    };\n  }\n  resetDesired() {\n    this.desiredDirection = this.fwd;\n  }\n  reflectX() {\n    this.fwd.x *= -1;\n  }\n  reflectY() {\n    this.fwd.y *= -1;\n  }\n}\nclass herdAgent extends agent {\n  constructor(app, x = 0, y = 0) {\n    super(app.loader.resources[\"./assets/img/Herder/herdAgent.png\"].texture, x, y, .03, 75);\n    this.avoidanceDist = 50;\n    this.foodSeekDistance = 150;\n    this.hunterFleeDistance = 200;\n  }\n}\nclass hunterAgent extends agent {\n  constructor(app, x = 0, y = 0, speed = 60) {\n    super(app.loader.resources[\"./assets/img/Herder/hunterAgent.png\"].texture, x, y, .05, speed);\n    this.huntDistance = 300;\n    this.eatenAgents = 0;\n    this.cloneThreshold = 5;\n    this.avoidanceDist = 75;\n  }\n}\nclass food extends PIXI.Sprite {\n  constructor(app, x = 0, y = 0) {\n    super(app.loader.resources[\"./assets/img/Herder/food.png\"].texture);\n    this.anchor.set(.5, .5);\n    this.scale.set(.01);\n    this.x = x;\n    this.y = y;\n    this.isEaten = false;\n  }\n}\nmodule.exports = {\n  herdAgent,\n  hunterAgent,\n  food\n};\n\n//# sourceURL=webpack://portfolio_project/./client/js/Herder/classes.js?");

/***/ }),

/***/ "./client/js/Herder/main.js":
/*!**********************************!*\
  !*** ./client/js/Herder/main.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("const classes = __webpack_require__(/*! ./classes.js */ \"./client/js/Herder/classes.js\");\nconst utils = __webpack_require__(/*! ./utilities.js */ \"./client/js/Herder/utilities.js\");\nconst app = new PIXI.Application({\n  width: 800,\n  height: 800\n});\ndocument.body.appendChild(app.view);\nlet sceneHeight = app.view.height;\nlet sceneWidth = app.view.width;\nconst gameHolder = document.querySelector(\"#gameHolder\");\n\n//load some fonts\nconst Roboto = 'Roboto Mono';\n\n// pre-load the images (this code works with PIXI v6)\napp.loader.add([\"./assets/img/Herder/food.png\", \"./assets/img/Herder/herdAgent.png\", \"./assets/img/Herder/hunterAgent.png\"]);\napp.loader.onProgress.add(e => {\n  console.log(`progress=${e.progress}`);\n});\napp.loader.onComplete.add(setup);\napp.loader.load();\n\n// aliases\nlet stage;\n\n// game variables\nlet startScene;\nlet gameScene;\nlet gameOverScene;\nlet herd = [];\nlet hunters = [];\nlet foodList = [];\nlet paused = true;\nlet steerStr = .5;\nlet maxHunterSpeed = 60;\nlet maxHerdSize = 0;\nlet score = 0;\nlet maxScore = 0;\nlet oldHerdSize = 0;\nlet timeAtCurrHerdSize = 0;\nlet timer = 0;\nlet scoreLabel;\nlet maxScoreLabel;\nlet gameOverScoreMessage;\nlet gameOverScoreMessageStyle;\nlet bgMusic, hunterHurt, herdHurt, herdReproduce;\nfunction setup() {\n  stage = app.stage;\n  // Create the `start` scene\n  startScene = new PIXI.Container();\n  stage.addChild(startScene);\n\n  // Create the main `game` scene and make it invisible\n  gameScene = new PIXI.Container();\n  gameScene.visible = false;\n  stage.addChild(gameScene);\n\n  // Create the `gameOver` scene and make it invisible\n  gameOverScene = new PIXI.Container();\n  gameOverScene.visible = false;\n  stage.addChild(gameOverScene);\n\n  // Create labels for all 3 scenes\n  createLabelsAndButtons();\n\n  // Load Sounds\n  bgMusic = new Howl({\n    src: ['./assets/audio/Herder/HerderTheme.mp3'],\n    loop: true,\n    volume: .3,\n    onloaderror: function (id, error) {\n      console.error('Error loading sound:', id, error);\n    }\n  });\n  hunterHurt = new Howl({\n    src: ['./assets/audio/Herder/HunterHurt.wav'],\n    volume: .6\n  });\n  herdHurt = new Howl({\n    src: ['./assets/audio/Herder/HerdHurt.wav'],\n    volume: .4\n  });\n  herdReproduce = new Howl({\n    src: ['./assets/audio/Herder/HerdReproduce.wav'],\n    volume: .3\n  });\n\n  // Start update loop\n  app.ticker.add(gameLoop);\n  // Start listening for click events on the canvas\n  // Now our `startScene` is visible\n  // Clicking the button calls startGame()\n}\nfunction createLabelsAndButtons() {\n  let buttonStyle = new PIXI.TextStyle({\n    fill: 0x33ff33,\n    fontSize: 48,\n    fontFamily: \"Roboto Mono\"\n  });\n  let startLabel1 = new PIXI.Text(\"Herder\");\n  startLabel1.style = new PIXI.TextStyle({\n    fill: 0x33ff33,\n    fontSize: 96,\n    fontFamily: \"Roboto Mono\",\n    stroke: 0x33ff33,\n    strokeThinkness: 2\n  });\n  let startLabelMetrics = PIXI.TextMetrics.measureText(\"Herder\", startLabel1.style);\n  startLabel1.x = sceneWidth / 2 - startLabelMetrics.width / 2;\n  startLabel1.y = 120;\n  startScene.addChild(startLabel1);\n  let startButton = new PIXI.Text(\"[P L A Y]\");\n  startButton.style = buttonStyle;\n  let startButtonMetrics = PIXI.TextMetrics.measureText(\"[P L A Y]\", buttonStyle);\n  startButton.x = sceneWidth / 2 - startButtonMetrics.width / 2;\n  startButton.y = sceneHeight - 150;\n  startButton.interactive = true;\n  startButton.buttonMode = true;\n  startButton.on(\"pointerup\", startGame);\n  startButton.on('pointerover', e => e.target.alpha = .7);\n  startButton.on('pointerout', e => e.currentTarget.alpha = 1);\n  startScene.addChild(startButton);\n  let textStyle = new PIXI.TextStyle({\n    fill: 0xFFFFFF,\n    fontSize: 18,\n    fontFamily: \"Roboto Mono\",\n    stroke: 0xFF0000,\n    strokeThickness: 4\n  });\n\n  // 3 - set up `gameOverScene`\n  // 3A - make game over text\n  let gameOverText = new PIXI.Text(\"Game Over!\");\n  textStyle = new PIXI.TextStyle({\n    fontSize: 64,\n    fontFamily: \"Roboto Mono\",\n    stroke: 0xFF0000,\n    strokeThickness: 6\n  });\n  gameOverText.style = textStyle;\n  let GameOverMetrics = PIXI.TextMetrics.measureText(\"Game Over\", gameOverText.style);\n  gameOverText.x = sceneWidth / 2 - GameOverMetrics.width / 2;\n  gameOverText.y = sceneHeight / 2 - 160;\n  gameOverScene.addChild(gameOverText);\n  gameOverScoreMessage = new PIXI.Text(\"TEST\");\n  gameOverScoreMessageStyle = new PIXI.TextStyle({\n    fontFamily: \"Roboto Mono\",\n    fontSize: 30,\n    fill: 0x00FF00\n  });\n  gameOverScoreMessage.style = gameOverScoreMessageStyle;\n  gameOverScoreMessage.y = sceneHeight / 2 - 60;\n  gameOverScene.addChild(gameOverScoreMessage);\n\n  // 3B - make \"play again?\" button\n  let playAgainButton = new PIXI.Text(\"Play Again?\");\n  playAgainButton.style = buttonStyle;\n  let playAgainMetric = PIXI.TextMetrics.measureText(\"Play Again?\", buttonStyle);\n  playAgainButton.x = sceneWidth / 2 - playAgainMetric.width / 2;\n  playAgainButton.y = sceneHeight - 100;\n  playAgainButton.interactive = true;\n  playAgainButton.buttonMode = true;\n  playAgainButton.on(\"pointerup\", startGame); // startGame is a function reference\n  playAgainButton.on('pointerover', e => e.target.alpha = 0.7); // concise arrow function with no brackets\n  playAgainButton.on('pointerout', e => e.currentTarget.alpha = 1.0); // ditto\n  gameOverScene.addChild(playAgainButton);\n  scoreLabel = new PIXI.Text(\"Score: \");\n  scoreLabel.style = new PIXI.TextStyle({\n    fontFamily: \"Roboto Mono\",\n    fontSize: 30,\n    fill: 0x00FF00\n  });\n  scoreLabel.x = 5;\n  scoreLabel.y = 5;\n  gameScene.addChild(scoreLabel);\n  maxScoreLabel = new PIXI.Text(\"High Score: \");\n  maxScoreLabel.style = scoreLabel.style;\n  maxScoreLabel.x = 5;\n  maxScoreLabel.y = 35;\n  gameScene.addChild(maxScoreLabel);\n}\nfunction startGame() {\n  startScene.visible = false;\n  gameOverScene.visible = false;\n  gameScene.visible = true;\n  //clear out hunters for restart\n  for (let hunterAgent of hunters) {\n    hunterAgent.isAlive = false;\n    gameScene.removeChild(hunterAgent);\n  }\n  hunters = hunters.filter(a => a.isAlive);\n  maxHunterSpeed = 60;\n  maxHerdSize = 0;\n  createHerd(5);\n  loadLevel();\n  score = 0;\n  bgMusic.play();\n}\nfunction gameLoop() {\n  if (paused) return;\n\n  // #1 - Calculate \"delta time\"\n  let dt = 1 / app.ticker.FPS;\n  if (dt > 1 / 12) dt = 1 / 12;\n  timer += dt;\n\n  // check max herd size and do scoring\n  checkMaxHerdSize();\n  DoScore(dt);\n\n  //Calculate Herd Desired Pos\n  //Get Herd Center & dir\n  let herdCenter = {\n    x: 0,\n    y: 0\n  };\n  let herdDir = 0;\n  for (let herdAgent of herd) {\n    herdCenter = {\n      x: herdCenter.x + herdAgent.x / herd.length,\n      y: herdCenter.y + herdAgent.y / herd.length\n    };\n    herdDir = herdDir + herdAgent.rotation / herd.length;\n  }\n  let herdDirVec = {\n    x: Math.cos(herdDir),\n    y: Math.sin(herdDir)\n  };\n\n  //Steer Agents\n  for (let herdAgent of herd) {\n    //cohesion\n    let steeringStr;\n    if (herd.length == 1) {\n      steeringStr = 1;\n    } else {\n      steeringStr = 1 / (herd.length - 1);\n    }\n    herdAgent.seek(herdCenter.x, herdCenter.y, steeringStr);\n    //borders\n    if (herdAgent.x <= herdAgent.borderSize || herdAgent.x >= sceneWidth - herdAgent.borderSize) {\n      herdAgent.seek(sceneWidth / 2, herdCenter.y, 10);\n    }\n    if (herdAgent.y <= herdAgent.borderSize || herdAgent.y >= sceneHeight - herdAgent.borderSize) {\n      herdAgent.seek(herdCenter.x, sceneHeight / 2, 10);\n    }\n    if (herdAgent.x <= herdAgent.borderSize / 2 || herdAgent.x >= sceneWidth - herdAgent.borderSize / 2) {\n      herdAgent.reflectX();\n    }\n    if (herdAgent.y <= herdAgent.borderSize / 2 || herdAgent.y >= sceneHeight - herdAgent.borderSize / 2) {\n      herdAgent.reflectY();\n    }\n\n    //avoidance\n    for (let otherAgent of herd) {\n      if (herdAgent == otherAgent) {\n        continue;\n      } //don't count ourselves for this!\n\n      let distance = utils.vectMag(herdAgent.x - otherAgent.x, herdAgent.y - otherAgent.y);\n      let avoidStr = .9;\n      if (distance <= herdAgent.avoidanceDist) {\n        herdAgent.flee(otherAgent.x, otherAgent.y, avoidStr * herdAgent.avoidanceDist / distance);\n      }\n    }\n    //alignment\n\n    herdAgent.seek(herdAgent.x + herdDirVec.x, herdAgent.y + herdDirVec.y, 2);\n\n    //seek food\n    let foodSeekStr = 150;\n    let nearestFood = -1;\n    if (foodList.length != 0) {\n      for (let foodItem of foodList) {\n        if (nearestFood == -1) {\n          nearestFood = foodItem;\n        }\n        let distance = utils.vectMag(herdAgent.x - foodItem.x, herdAgent.y - foodItem.y);\n        if (distance < utils.vectMag(herdAgent.x - nearestFood.x, herdAgent.y - nearestFood.y)) {\n          nearestFood = foodItem;\n        }\n      }\n      let nearestFoodDist = utils.vectMag(herdAgent.x - nearestFood.x, herdAgent.y - nearestFood.y);\n      if (nearestFoodDist <= herdAgent.foodSeekDistance) {\n        herdAgent.seek(nearestFood.x, nearestFood.y, foodSeekStr / nearestFoodDist);\n      } else {\n        herdAgent.seek(nearestFood.x, nearestFood.y, .4 * foodSeekStr / nearestFoodDist);\n      }\n    }\n\n    //flee nearby hunters\n    let hunterFleeStr = 10;\n    for (let hunterAgent of hunters) {\n      let distance = utils.vectMag(herdAgent.x - hunterAgent.x, herdAgent.y - hunterAgent.y);\n      if (distance <= herdAgent.hunterFleeDistance) {\n        herdAgent.flee(hunterAgent.x, hunterAgent.y, hunterFleeStr);\n      }\n    }\n  }\n\n  //steer hunters\n  for (let hunterAgent of hunters) {\n    let nearestHerd;\n    let nearestDist = 1000000000; //always higher than our nearest one\n    for (let herdAgent of herd) {\n      let distance = utils.vectMag(herdAgent.x - hunterAgent.x, herdAgent.y - hunterAgent.y);\n      if (distance <= nearestDist) {\n        nearestDist = distance;\n        nearestHerd = herdAgent;\n      }\n    }\n    if (nearestDist <= hunterAgent.huntDistance) {\n      hunterAgent.seek(nearestHerd.x, nearestHerd.y);\n    } else {\n      hunterAgent.seek(herdCenter.x, herdCenter.y);\n    }\n    for (let otherHunter of hunters) {\n      let distance = utils.vectMag(hunterAgent.x - otherHunter.x, hunterAgent.y - otherHunter.y);\n      if (distance <= hunterAgent.avoidanceDist) {\n        hunterAgent.flee(otherHunter.x, otherHunter.y, 1);\n      }\n    }\n  }\n\n  // #3 - Move Herd\n  //herd agents normalize desired,\n  //then steer fwd toward desired\n  //then, reset desired\n  for (let herdAgent of herd) {\n    herdAgent.normalizeDesiredDir();\n    herdAgent.steer(steerStr * dt);\n    herdAgent.resetDesired();\n    herdAgent.rotateToFwd();\n    herdAgent.move(dt);\n  }\n\n  // #4 - Move Hunters - same as herd\n  for (let hunterAgent of hunters) {\n    hunterAgent.normalizeDesiredDir();\n    hunterAgent.steer(steerStr * dt);\n    hunterAgent.resetDesired();\n    hunterAgent.rotateToFwd();\n    hunterAgent.move(dt);\n  }\n\n  // #5 - Check for Collisions\n  for (let herdAgent of herd) {\n    //hunter eats herd\n    for (let hunterAgent of hunters) {\n      if (herdAgent.isAlive && utils.rectsIntersect(herdAgent, hunterAgent)) {\n        //hitSound.play();\n        gameScene.removeChild(herdAgent);\n        herdAgent.isAlive = false;\n        herdHurt.play();\n        herd = herd.filter(a => a.isAlive);\n        hunterAgent.eatenAgents++;\n        if (hunterAgent.eatenAgents >= hunterAgent.cloneThreshold) {\n          hunterAgent.eatenAgents = 0;\n          createHunters(2, hunterAgent.speed * 1.1);\n          hunterAgent.speed *= 1.2;\n        }\n      }\n    }\n    //herd eats food\n    for (let foodItem of foodList) {\n      if (herdAgent.isAlive && utils.rectsIntersect(herdAgent, foodItem)) {\n        gameScene.removeChild(foodItem);\n        foodItem.isEaten = true;\n        createHerd(2);\n        herdReproduce.play();\n        foodList = foodList.filter(f => !f.isEaten);\n      }\n    }\n  }\n\n  //filter lists\n  herd = herd.filter(a => a.isAlive);\n  hunters = hunters.filter(a => a.isAlive);\n  foodList = foodList.filter(f => !f.isEaten);\n\n  // #7 - Is game over?\n  if (herd.length == 0) {\n    end();\n    return; // return here so we skip #8 below\n  }\n\n  // #8 - Load next level\n  if (hunters.length == 0) {\n    loadLevel();\n  }\n}\nfunction loadLevel() {\n  paused = false;\n  spawnFood(10);\n  createHunters(Math.max(5, Math.trunc(herd.length / 3)));\n}\nfunction end() {\n  paused = true;\n  bgMusic.stop();\n  gameOverScene.visible = true;\n  gameScene.visible = false;\n}\nfunction fireBullet(e) {\n  if (paused) return;\n}\nfunction createHerd(numAgents) {\n  for (let i = 0; i < numAgents; i++) {\n    let newAgent = new classes.herdAgent(app, Math.random() * (sceneWidth - 50) + 25, Math.random() * (sceneHeight - 50) + 25);\n    herd.push(newAgent);\n    gameScene.addChild(newAgent);\n  }\n  checkMaxHerdSize();\n}\nfunction createHunters(numAgents, speed = maxHunterSpeed) {\n  if (speed > maxHunterSpeed) {\n    maxHunterSpeed = speed;\n  }\n  for (let i = 0; i < numAgents; i++) {\n    let rightLeft = Math.round(Math.random());\n    let topBottom = Math.round(Math.random());\n    let posX = sceneWidth * rightLeft;\n    let posY = sceneHeight * topBottom;\n    if (posX == 0) {\n      posX -= 250;\n    } else {\n      posX += 250;\n    }\n    if (posY == 0) {\n      posY -= 250;\n    } else {\n      posY += 250;\n    }\n    let newAgent = new classes.hunterAgent(app, posX, posY, speed);\n    newAgent.interactive = true;\n    newAgent.eventMode = 'dynamic';\n    newAgent.cursor = 'pointer';\n    newAgent.on('pointerup', e => {\n      e.target.isAlive = false;\n      gameScene.removeChild(e.target);\n      hunterHurt.play();\n    });\n    hunters.push(newAgent);\n    gameScene.addChild(newAgent);\n  }\n}\nfunction spawnFood(numFood) {\n  for (let i = 0; i < numFood; i++) {\n    let newFood = new classes.food(app, Math.random() * (sceneWidth - 50) + 25, Math.random() * (sceneHeight - 50) + 25);\n    foodList.push(newFood);\n    gameScene.addChild(newFood);\n  }\n}\nfunction checkMaxHerdSize() {\n  if (herd.length > maxHerdSize) {\n    maxHerdSize = herd.length;\n  }\n}\nfunction DoScore(dt) {\n  let calculatedScoreBonus = 0;\n  if (herd.length >= oldHerdSize) {\n    timeAtCurrHerdSize += dt;\n    oldHerdSize = herd.length;\n  } else {\n    if (oldHerdSize == maxHerdSize) {\n      calculatedScoreBonus = Math.trunc(timeAtCurrHerdSize * herd.length);\n    }\n    if (herd.length < oldHerdSize) {\n      timeAtCurrHerdSize = 0;\n    }\n    oldHerdSize = herd.length;\n  }\n  let scoreDelta = herd.length * dt + calculatedScoreBonus;\n  score += scoreDelta;\n  if (score > maxScore) {\n    maxScore = Math.trunc(score);\n  }\n  maxScoreLabel.text = \"High Score: \" + maxScore;\n  let text = \"Your Highest Score Was \" + Math.trunc(score);\n  gameOverScoreMessage.text = text;\n  let Metrics = new PIXI.TextMetrics.measureText(text, gameOverScoreMessageStyle);\n  gameOverScoreMessage.x = sceneWidth / 2 - Metrics.width / 2;\n  scoreLabel.text = \"Score: \" + Math.trunc(score);\n}\n\n//# sourceURL=webpack://portfolio_project/./client/js/Herder/main.js?");

/***/ }),

/***/ "./client/js/Herder/utilities.js":
/*!***************************************!*\
  !*** ./client/js/Herder/utilities.js ***!
  \***************************************/
/***/ ((module) => {

eval("function lerp(start, end, amt) {\n  return start * (1 - amt) + amt * end;\n}\n\n// we didn't use this one\n//function cosineInterpolate(y1, y2, amt){\n//      let amt2 = (1 - Math.cos(amt * Math.PI)) / 2;\n//      return (y1 * (1 - amt2)) + (y2 * amt2);\n//}\nfunction clamp(val, min, max) {\n  return val < min ? min : val > max ? max : val;\n}\n\n// bounding box collision detection - it compares PIXI.Rectangles\nfunction rectsIntersect(a, b) {\n  var ab = a.getBounds();\n  var bb = b.getBounds();\n  return ab.x + ab.width > bb.x && ab.x < bb.x + bb.width && ab.y + ab.height > bb.y && ab.y < bb.y + bb.height;\n}\nfunction getRandomUnitVector() {\n  let x = getRandom(-1, 1);\n  let y = getRandom(-1, 1);\n  let length = Math.sqrt(x * x + y * y);\n  if (length == 0) {\n    // very unlikely\n    x = 1; // point right\n    y = 0;\n    length = 1;\n  } else {\n    x /= length;\n    y /= length;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction getRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\nfunction vectMag(x, y) {\n  return Math.sqrt(x * x + y * y);\n}\nmodule.exports = {\n  lerp,\n  clamp,\n  rectsIntersect,\n  getRandomUnitVector,\n  getRandom,\n  vectMag\n};\n\n//# sourceURL=webpack://portfolio_project/./client/js/Herder/utilities.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./client/js/Herder/main.js");
/******/ 	
/******/ })()
;